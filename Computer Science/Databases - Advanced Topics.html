<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Databases - Advanced Topics</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__left">
    <div class="stackedit__toc">
      
<ul>
<li><a href="#databases-advanced-topics-in-sql">Databases: Advanced Topics in SQL</a>
<ul>
<li></li>
</ul>
</li>
<li><a href="#indexes">Indexes</a>
<ul>
<li></li>
</ul>
</li>
<li><a href="#transactions">Transactions</a>
<ul>
<li></li>
<li><a href="#isolation-level">Isolation Level</a></li>
</ul>
</li>
<li><a href="#references">References</a></li>
</ul>

    </div>
  </div>
  <div class="stackedit__right">
    <div class="stackedit__html">
      <h1 id="databases-advanced-topics-in-sql">Databases: Advanced Topics in SQL</h1>
<p>Created: 28 Nov 2020<br>
Modified: 2 Dec 2020</p>
<h3 id="table-of-contents">Table of Contents</h3>
<ul>
<li>Indexes</li>
<li>Transactions</li>
<li>Constraints and Triggers</li>
<li>Views and Authorization</li>
</ul>
<h1 id="indexes">Indexes</h1>
<p>What is an index of a database?</p>
<ul>
<li>Primary mechanism to get improved performance on a database</li>
<li>Presistent data structures, stored in database</li>
<li>Make queries more efficient by skipping the scanning of the full table</li>
</ul>
<h3 id="utility">Utility</h3>
<ul>
<li>Index = difference between full table scans and imeediate location of tuples (rows)
<ul>
<li>order of magnitude performance differences</li>
</ul>
</li>
<li>Underlying data structures
<ul>
<li>Balanced trees (B trees / B+ trees)
<ul>
<li>for both equality and inequality queries</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mtext>log&nbsp;</mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\text{log } n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord text"><span class="mord">log&nbsp;</span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span> performance</li>
</ul>
</li>
<li>Hash tables
<ul>
<li>for attribute = value queries</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> performance if well designed</li>
</ul>
</li>
</ul>
</li>
<li>Many DBMS’s build indexes automatically on <strong>Primary Key</strong> (and somestimes <strong>Unqiue</strong>) attributes.</li>
<li>Implementation: Query planning and optimization</li>
</ul>
<h3 id="downsides-of-indexes">Downsides of indexes</h3>
<ol>
<li>Extra space - minor problem</li>
<li>Index creation - medium, takes time</li>
<li>Index maintainance (upon modification of table) - the most important concern</li>
</ol>
<h3 id="benefits-of-an-index-depends-on">Benefits of an index depends on</h3>
<ul>
<li>Size of table (and possibly layouts)</li>
<li>Data distribution</li>
<li>Query sv. update load</li>
</ul>
<h3 id="physical-design-advisor">“Physical” design advisor</h3>
<p>Input: Database (statistics) and workload<br>
Output: Recommanded indexes</p>
<h3 id="query-optimizer">Query optimizer</h3>
<p>Input: Database (statistics), query or update, and existing indexes<br>
Output: Best execution with an estimated cost</p>
<h3 id="sql-syntax">SQL Syntax:</h3>
<p>Create an index on the attribute A</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> indexName <span class="token keyword">on</span> T<span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Create n indexes on the attribute A1 to An</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> indexName <span class="token keyword">on</span> T<span class="token punctuation">(</span>A1<span class="token punctuation">,</span> A2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> An<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Create a unique index on the attribute A</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">UNIQUE</span> <span class="token keyword">INDEX</span> indexName <span class="token keyword">on</span> T<span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Delete an index</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> indexName<span class="token punctuation">;</span>
</code></pre>
<h1 id="transactions">Transactions</h1>
<p>Motivated by two independent requirements:</p>
<ul>
<li>Concurrent database access</li>
<li>Resilience to system failure</li>
</ul>
<h3 id="concurrent-access-by-different-applications">Concurrent Access (by different applications)</h3>
<ul>
<li>Attribute level</li>
<li>Tuple level</li>
<li>Table level</li>
<li>Multi-statement level</li>
</ul>
<h3 id="concurrency-goals">Concurrency goals</h3>
<ul>
<li>Execute sequence of SQL statements so that they appear to be runing in isolation.
<ul>
<li>Simple solution: execute them in sequence</li>
</ul>
</li>
<li>But want to enable concurrency when safe to do so.
<ul>
<li>e.g. Multiprocessor, multithreaded, asyn. I/O</li>
</ul>
</li>
</ul>
<h3 id="resilience-to-system-failures">Resilience to System Failures</h3>
<ul>
<li>Failure scenarios:
<ul>
<li>Crash during a bulk load of data</li>
<li>Crash during table migration</li>
<li>Crash during lots of updates</li>
</ul>
</li>
<li>System failure goal: Guarantee <strong>all-or-nothing</strong> execution, regardless of failure</li>
</ul>
<h3 id="solution-to-both-concurrency--failures-transactions">Solution to both Concurrency &amp; Failures: Transactions</h3>
<p>A transaction is a squence of one or more SQL operations treated as a unit. SQL standard:</p>
<ul>
<li>Transaction begins automatically on the first SQL statement</li>
<li>On “commit” tranaction ends and new one begins</li>
<li>Current transaction ends on session termination</li>
<li>“Autocommit” turns each statement into transaction</li>
</ul>
<p>Other properties:</p>
<ul>
<li>Transactions appear to run in isolation</li>
<li>If the system fails, each transactions changes are relected with entirely / not at all.</li>
</ul>
<h3 id="acid-properties">ACID Properties</h3>
<ul>
<li><strong>A</strong>tomicity - each transaction is "all-or-nothing’, never left half done (logging).</li>
<li><strong>C</strong>onsistency</li>
<li><strong>I</strong>solation</li>
<li><strong>D</strong>urability - If system craches after tranaction commits, all effect of transactions remain in the database (logging).</li>
</ul>
<p>Serializability</p>
<ul>
<li>Operations may be interleaved, but execution must be equivalent to some sequential (serial) order of all transactions.</li>
</ul>
<p>Transaction Rollback (= Abort)</p>
<ul>
<li>Undoes partial effects  of transactions (<strong>A</strong>tomicity)</li>
<li>Can be system- / client-initiated</li>
<li>“Rollback” command only undoes the effects on data itself in the DB. It doesn’t un do things like modifying variables.</li>
</ul>
<p>Consistency:</p>
<ul>
<li>For each client and each transaction:
<ul>
<li>assume all constraints hold when transaction begins</li>
<li>must guarantee all constaints hold when transaction ends</li>
</ul>
</li>
<li>Serializability =&gt; constraints always hold</li>
</ul>
<h2 id="isolation-level">Isolation Level</h2>
<p>4 types of isolation level:</p>
<ul>
<li>Read Uncommitted</li>
<li>Read Committed</li>
<li>Repeatable Read</li>
<li>Serizlizable (by default)</li>
</ul>
<p>A “weaker” isolation level reduce overhead and increase concurrency, but at the same time reduce the concurrency guarantee.</p>
<h3 id="dirty-reads">Dirty Reads</h3>
<p>“Dirty” data item: written by an uncommitted transaction</p>
<h3 id="isolation-level-read-uncommitted">Isolation Level: <code>READ UNCOMMITTED</code></h3>
<ul>
<li>A transaction may perform dirty reads</li>
<li>Example: T1 and T2 run concurrently</li>
</ul>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token comment">--T1:</span>
<span class="token keyword">UPDATE</span> Student <span class="token keyword">SET</span> GPA <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1.1</span><span class="token punctuation">)</span><span class="token operator">*</span>GPA <span class="token keyword">WHERE</span> sizeHS <span class="token operator">&gt;</span> <span class="token number">2500</span><span class="token punctuation">;</span>
</code></pre>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token comment">--T2: </span>
<span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>GPA<span class="token punctuation">)</span> <span class="token keyword">FROM</span> Student<span class="token punctuation">;</span>
</code></pre>
<p>By default, T1 and T2 are serialized, resulting in an operation order of either {T1, T2} or {T2, T1}.</p>
<p>To increase the concurreny, we can set a “weaker” isolation level for T2:</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token comment">--T1:</span>
<span class="token keyword">UPDATE</span> Student <span class="token keyword">SET</span> GPA <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1.1</span><span class="token punctuation">)</span><span class="token operator">*</span>GPA <span class="token keyword">WHERE</span> sizeHS <span class="token operator">&gt;</span> <span class="token number">2500</span><span class="token punctuation">;</span>
</code></pre>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token comment">--T2: </span>
<span class="token keyword">SET</span> <span class="token keyword">TRANSACTION</span> <span class="token keyword">ISOLATION LEVEL</span> <span class="token keyword">READ</span> <span class="token keyword">UNCOMMITTED</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>GPA<span class="token punctuation">)</span> <span class="token keyword">FROM</span> Student<span class="token punctuation">;</span>
</code></pre>
<p>This makes T1 &amp; T2 run concurrently, i.e. T2 computes the average of GPA while T1 is updating the GPA.</p>
<h3 id="isolation-level-read-committed">Isolation Level: <code>READ COMMITTED</code></h3>
<ul>
<li>A transaction may <strong>not</strong> perform dirty reads</li>
<li>Still doesn’t guarantee global serializability</li>
</ul>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token comment">--T1:</span>
<span class="token keyword">UPDATE</span> Student <span class="token keyword">SET</span> GPA <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1.1</span><span class="token punctuation">)</span><span class="token operator">*</span>GPA <span class="token keyword">WHERE</span> sizeHS <span class="token operator">&gt;</span> <span class="token number">2500</span><span class="token punctuation">;</span>
</code></pre>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token comment">--T2: </span>
<span class="token keyword">SET</span> <span class="token keyword">TRANSACTION</span> <span class="token keyword">ISOLATION LEVEL</span> <span class="token keyword">READ</span> <span class="token keyword">COMMITTED</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>GPA<span class="token punctuation">)</span> <span class="token keyword">FROM</span> Student<span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token function">MAX</span><span class="token punctuation">(</span>GPA<span class="token punctuation">)</span> <span class="token keyword">FROM</span> Student<span class="token punctuation">;</span>
</code></pre>
<ul>
<li>Possible outcome: <code>AVG(GPA)</code> -&gt; <code>GPA = (1.1)*GPA</code> -&gt; <code>MAX(GPA)</code></li>
</ul>
<h3 id="isolation-level-repaetable-read">Isolation Level: <code>REPAETABLE READ</code></h3>
<ul>
<li>A transaction may <strong>not</strong> perform dirty reads</li>
<li>An iteam read multiple times cannot change value</li>
<li>still doesn’t guarantee global serializability</li>
</ul>
<p>Example 1:</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token comment">-- T1:</span>
<span class="token keyword">UPDATE</span> Student <span class="token keyword">SET</span> GPA <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1.1</span><span class="token punctuation">)</span> <span class="token operator">*</span> GPA<span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> Student <span class="token keyword">SET</span> sizeHS <span class="token operator">=</span> <span class="token number">1500</span> <span class="token keyword">WHERE</span> sID <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
</code></pre>
<p><em>concurrent with …</em></p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token comment">--T2:</span>
<span class="token keyword">SET</span> <span class="token keyword">TRANSACTION</span> <span class="token keyword">ISOLATION LEVEL</span> <span class="token keyword">REPEATABLE</span> <span class="token keyword">READ</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>GPA<span class="token punctuation">)</span> <span class="token keyword">FROM</span> Student<span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>sizeHS<span class="token punctuation">)</span> <span class="token keyword">FROM</span> Student<span class="token punctuation">;</span>
</code></pre>
<p>A possible concurrent sequence: <code>SET GPA</code> -&gt; <code>AVG(GPA)</code> -&gt; <code>SET sizeHS</code> -&gt; <code>AVG(sizeHS)</code></p>
<h4 id="phantom-tuples">Phantom tuples</h4>
<ul>
<li>But a relation can change!</li>
</ul>
<p>Example 2:</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token comment">-- T1:</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Student <span class="token punctuation">[</span><span class="token number">100</span> new tuples<span class="token punctuation">]</span>
</code></pre>
<p><em>concurrent with …</em></p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token comment">--T2:</span>
<span class="token keyword">SET</span> <span class="token keyword">TRANSACTION</span> <span class="token keyword">ISOLATION LEVEL</span> <span class="token keyword">REPEATABLE</span> <span class="token keyword">READ</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>GPA<span class="token punctuation">)</span> <span class="token keyword">FROM</span> Student<span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>GPA<span class="token punctuation">)</span> <span class="token keyword">FROM</span> Student<span class="token punctuation">;</span>
</code></pre>
<p>Possible outcome:<br>
The two <code>AVG(GPA)</code> statements return different results. The first execution of <code>AVG(GPA)</code> only locks the existing tuples. The insertions of new tuples between the two executions of <code>AVG(GPA)</code> are allowed.</p>
<ul>
<li>However, deletion of tuples is not allowed!</li>
</ul>
<p>Example 3:</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token comment">-- T1:</span>
<span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> Student <span class="token punctuation">[</span><span class="token number">100</span> tuples<span class="token punctuation">]</span>
</code></pre>
<p><em>concurrent with …</em></p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token comment">--T2:</span>
<span class="token keyword">SET</span> <span class="token keyword">TRANSACTION</span> <span class="token keyword">ISOLATION LEVEL</span> <span class="token keyword">REPEATABLE</span> <span class="token keyword">READ</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>GPA<span class="token punctuation">)</span> <span class="token keyword">FROM</span> Student<span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>GPA<span class="token punctuation">)</span> <span class="token keyword">FROM</span> Student<span class="token punctuation">;</span>
</code></pre>
<p>Possible outcome:</p>
<ul>
<li>Two statements return the same value, either the <code>AVG(GPA)</code> before or after the complete deletion.</li>
<li>If the first <code>AVG(GPA)</code> is executed before <code>T1</code>, all tuples in <code>Student</code> are read and locked, preventing any deletion before <code>T2</code> completes.</li>
</ul>
<h3 id="read-only-transactions"><code>READ ONLY</code> Transactions</h3>
<ul>
<li>Help system optimize performance</li>
<li>Independent of isolation level</li>
</ul>
<p>Example:</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SET</span> <span class="token keyword">TRANSACTION</span> <span class="token keyword">READ</span> ONLY<span class="token punctuation">;</span>
<span class="token keyword">SET</span> <span class="token keyword">TRANSACTION</span> <span class="token keyword">ISOLATION LEVEL</span> <span class="token keyword">REPEATABLE</span> <span class="token keyword">READ</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>GPA<span class="token punctuation">)</span> <span class="token keyword">FROM</span> Student<span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token function">MAX</span><span class="token punctuation">(</span>GPA<span class="token punctuation">)</span> <span class="token keyword">FROM</span> Student<span class="token punctuation">;</span>
</code></pre>
<p>The first line hints the query optimizer that the transaction performs only querying operations.</p>
<h3 id="isolation-level-summary">Isolation Level: Summary</h3>

<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">Isolation Level</th>
<th align="center">Dirty Read</th>
<th align="center">Non-repeatable Read</th>
<th align="center">Phantoms</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">Weakest</td>
<td align="center"><code>Read Uncommitted</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>Read Committed</code></td>
<td align="center">N</td>
<td align="center">Y</td>
<td align="center">Y</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>Repeatable Read</code></td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">Y</td>
</tr>
<tr>
<td align="center">Strongest</td>
<td align="center"><code>Serializable</code></td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
</tr>
</tbody>
</table><ul>
<li>Standard Default: <code>Serializable</code></li>
<li>Weaker isolation levels:
<ul>
<li>Increased conccurency + decreased overhead = increased performance</li>
<li>Weaker consistency guarantees</li>
<li>Some systems, e.g. MySQL and Oracle, have default <code>Repeatable Read</code></li>
</ul>
</li>
<li>Isolation level per transaction and “eye of the beholder”
<ul>
<li>Each transaction’s reads must conform to its isolation level.</li>
</ul>
</li>
</ul>
<h1 id="references">References</h1>
<ul>
<li>Databases: Advanced Topics in SQL<br>
Prof. Jennifer Widom<br>
Dean, School of Engineering at Stanford University<br>
URL: <a href="https://www.edx.org/course/advanced-topics-in-sql">https://www.edx.org/course/advanced-topics-in-sql</a></li>
</ul>
<blockquote>
<p>Written with <a href="https://stackedit.io/">StackEdit</a>.</p>
</blockquote>

    </div>
  </div>
</body>

</html>
